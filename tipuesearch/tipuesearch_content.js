var tipuesearch = {"pages":[{"title":" ","text":"Emulators Motivation and Usage Are you hoping for a world with full compiler support for recent Fortran\nstandards?  Emulating an unsupported feature facilitates using the feature prior\nto compiler support.  This path offers minimal impact on future code. Switching\nto the compiler's version of a feature might involve little more than toggling a\npreprocessor macro: #ifdef EMULATE_COLLECTIVES use collectives_m , only : co_sum #endif and then not passing the macro at EMULATE_COLLECTIVES to the compiler to\nturn eliminate the emulated version of co_sum from the source code before\ncompiling. Emulators contains a few emulated procedures and preprocessor macros that\ntrigger their compilation.  We make no attempt at comprehensiveness. \nWe support only the procedures, arguments, and argument types, kinds, \nand ranks that we have found useful in our own work.  We welcome pull \nrequests that expand Emulators's emulators in number or capability. Contents Emulated features:\n* Fortran 2008 intrinsic function: findloc * Fortran 2018 collective subroutines: co_sum , co_broadcast Those who find the collective subroutines useful might also be interested\nin language extensions such as the Sourcery library's co_all subroutine,\nwhich provides a parallel, collective logical operation analogous to the all intrinsic function. Prerequisites Emulators builds with a Fortran compiler that supports the following features: Error stop Emulators's only dependency, Assert , uses Fortran 2018 error stop ,\n     which several compilers have supported before supporting the features\n     that Emulators emulates.  Please submit an issue or pull request if you prefer to have the option to build without Assert. Coarrays and synchronization Emulators's Fortran 2018 collective-subroutine emulators use Fortran 2008\n     coarrays and synchronization. Downloading, building and testing Parallel execution With gfortran and OpenCoarrays installed, execute the following commands in\na bash -like shell to include all emulators in the build: git clone git@github.com:sourceryinstitute/emulators\nfpm test \\\n  --runner cafrun -n 2 \\\n  --compiler caf \\\n  --flag \"-cpp -DEMULATE_INTRINSICS -DEMULATE_COLLECTIVES\" Serial execution With gfortran installed, execute the following commands in\na bash -like shell to include all emulators in the build: git clone git@github.com:sourceryinstitute/emulators\nfpm test --flag \"-cpp -DEMULATE_INTRINSICS -DEMULATE_COLLECTIVES -fcoarray=single\" Developer Info Damian Rouson","tags":"home","loc":"index.html"},{"title":"collectives_s.F90 – ","text":"This file depends on sourcefile~~collectives_s.f90~~EfferentGraph sourcefile~collectives_s.f90 collectives_s.F90 sourcefile~collectives_m.f90 collectives_m.F90 sourcefile~collectives_s.f90->sourcefile~collectives_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules collectives_s Source Code collectives_s.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( collectives_m ) collectives_s use assert_m , only : assert implicit none contains module procedure ensure_non_empty_collectives_m end procedure #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_SUM module procedure co_sum_integer !! Binary tree collective sum reduction integer , save :: total [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total = a even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total = total + total [ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total = total + total [ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a = total else call co_broadcast ( total , source_image = default_root_image ) a = total end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure module procedure co_sum_real32_1D_array !! Binary tree collective sum reduction real ( real32 ), allocatable :: total (:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( total ( size ( a ))[ * ]) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total (:) = a (:) even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total (:) = total (:) + total (:)[ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total (:) = total (:) + total (:)[ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a (:) = total (:) else call co_broadcast ( total , source_image = default_root_image ) a (:) = total (:) end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure module procedure co_sum_real32_2D_array !! Binary tree collective sum reduction real ( real32 ), allocatable :: total (:,:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( total ( size ( a , 1 ), size ( a , 2 ))[ * ]) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total (:,:) = a (:,:) even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total (:,:) = total (:,:) + total (:,:)[ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total (:,:) = total (:,:) + total (:,:)[ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a (:,:) = total (:,:) else call co_broadcast ( total , source_image = default_root_image ) a (:,:) = total (:,:) end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure module procedure co_sum_real64_1D_array !! Binary tree collective sum reduction real ( real64 ), allocatable :: total (:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( total ( size ( a ))[ * ]) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total (:) = a (:) even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total (:) = total (:) + total (:)[ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total (:) = total (:) + total (:)[ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a (:) = total (:) else call co_broadcast ( total , source_image = default_root_image ) a (:) = total (:) end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure module procedure co_sum_real64_2D_array !! Binary tree collective sum reduction real ( real64 ), allocatable :: total (:,:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( total ( size ( a , 1 ), size ( a , 2 ))[ * ]) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if total (:,:) = a (:,:) even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) total (:,:) = total (:,:) + total (:,:)[ even_child_image ] end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) total (:,:) = total (:,:) + total (:,:)[ odd_child_image ] end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a (:,:) = total (:,:) else call co_broadcast ( total , source_image = default_root_image ) a (:,:) = total (:,:) end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end procedure #endif /* EMULATE_COLLECTIVES || defined EMULATE_CO_SUM*/ #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_BROADCAST module procedure co_broadcast_logical !! Binary tree collective broadcast logical , save :: message [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message = message [ parent_image ] else message = a !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a = message relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure module procedure co_broadcast_integer !! Binary tree collective broadcast integer , save :: message [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message = message [ parent_image ] else message = a !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a = message relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure module procedure co_broadcast_real32_1D_array !! Binary tree collective broadcast real ( real32 ), allocatable :: message (:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( message ( size ( a ))[ * ]) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message (:) = message (:)[ parent_image ] else message (:) = a (:) !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a (:) = message (:) relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure module procedure co_broadcast_real32_2D_array !! Binary tree collective broadcast real ( real32 ), allocatable :: message (:,:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( message ( size ( a , 1 ), size ( a , 2 ))[ * ]) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message (:,:) = message (:,:)[ parent_image ] else message (:,:) = a (:,:) !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a (:,:) = message (:,:) relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure module procedure co_broadcast_real64_1D_array !! Binary tree collective broadcast real ( real64 ), allocatable :: message (:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( message ( size ( a ))[ * ]) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message (:) = message (:)[ parent_image ] else message (:) = a (:) !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a (:) = message (:) relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure module procedure co_broadcast_real64_2D_array !! Binary tree collective broadcast real ( real64 ), allocatable :: message (:,:)[:] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) allocate ( message ( size ( a , 1 ), size ( a , 2 ))[ * ]) my_image = this_image () if ( my_image == source_image ) then my_node = root_node else my_node = merge ( source_image , my_image , my_image == default_root_image ) end if parent_node = my_node / 2 default_parent_image = my_image / 2 if ( parent_node == root_node ) then parent_image = source_image else if ( default_parent_image == source_image ) then parent_image = default_root_image else parent_image = parent_node end if if ( exists ( parent_image )) then sync images ( parent_image ) message (:,:) = message (:,:)[ parent_image ] else message (:,:) = a (:,:) !! define the message for broadcasting down the tree when the orphaned root image falls through this branch end if even_child_node = 2 * my_node even_child_image = merge ( even_child_node , default_root_image , even_child_node /= source_image ) if ( exists ( even_child_node ) ) sync images ( even_child_image ) odd_child_node = 2 * my_node + 1 odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= source_image ) if ( exists ( odd_child_node ) ) sync images ( odd_child_image ) a (:,:) = message (:,:) relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 end procedure #endif /* defined EMULATE_COLLECTIVES || defined EMULATE_CO_BROADCAST */ #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_REDUCE module subroutine co_reduce_logical ( a , operation , result_image , stat , errmsg ) abstract interface pure function operation_i ( x , y ) logical , intent ( in ) :: x , y logical :: operation_i end function end interface logical , intent ( inout ) :: a procedure ( operation_i ) :: operation integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg !! Binary tree collective reduction logical , save :: reduction [ * ] integer , parameter :: root_node = 1 , default_root_image = 1 integer even_child_image , odd_child_image , parent_image , my_image integer even_child_node , odd_child_node , parent_node , my_node , default_parent_image integer , allocatable :: relatives (:) my_image = this_image () if (. not . present ( result_image )) then my_node = my_image else if ( my_image == result_image ) then my_node = root_node else my_node = merge ( result_image , my_image , my_image == default_root_image ) end if end if parent_node = my_node / 2 default_parent_image = my_image / 2 if (. not . present ( result_image )) then parent_image = parent_node else if ( parent_node == root_node ) then parent_image = result_image else if ( default_parent_image == result_image ) then parent_image = default_root_image else parent_image = parent_node end if end if reduction = a even_child_node = 2 * my_node if (. not . present ( result_image )) then even_child_image = even_child_node else even_child_image = merge ( even_child_node , default_root_image , even_child_node /= result_image ) end if if ( exists ( even_child_node ) ) then sync images ( even_child_image ) reduction = operation ( reduction , reduction [ even_child_image ]) end if odd_child_node = 2 * my_node + 1 if (. not . present ( result_image )) then odd_child_image = odd_child_node else odd_child_image = merge ( odd_child_node , default_root_image , odd_child_node /= result_image ) end if if ( exists ( odd_child_node ) ) then sync images ( odd_child_image ) reduction = operation ( reduction , reduction [ odd_child_image ]) end if if ( exists ( parent_image )) sync images ( parent_image ) if ( present ( result_image )) then if ( my_image == result_image ) a = reduction else call co_broadcast ( reduction , source_image = default_root_image ) a = reduction end if if ( present ( errmsg )) errmsg = \"\" if ( present ( stat )) stat = 0 relatives = [ parent_image , even_child_image , odd_child_image ] relatives = pack ( relatives , exists ( relatives )) sync images ( relatives ) end subroutine elemental function exists ( image ) result ( image_exists ) !! Result true if image number is within the closed range [1,num_images()] integer , intent ( in ) :: image logical image_exists image_exists = ( image > 0 . and . image <= num_images ()) end function #endif /* defined EMULATE_COLLECTIVES || defined EMULATE_CO_REDUCE */ end submodule collectives_s","tags":"","loc":"sourcefile/collectives_s.f90.html"},{"title":"intrinsics_m.F90 – ","text":"Files dependent on this one sourcefile~~intrinsics_m.f90~~AfferentGraph sourcefile~intrinsics_m.f90 intrinsics_m.F90 sourcefile~intrinsics_s.f90 intrinsics_s.F90 sourcefile~intrinsics_s.f90->sourcefile~intrinsics_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules intrinsics_m Source Code intrinsics_m.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module intrinsics_m !! summary: Fortran 2003 emulation of a Fortran 2008 intrinsic function: findloc !! author: Damian Rouson implicit none private #if defined EMULATE_INTRINSICS || defined EMULATE_FINDLOC public :: findloc #endif interface module subroutine ensure_non_empty_instrinsic_m end subroutine end interface #if defined EMULATE_INTRINSICS || defined EMULATE_FINDLOC interface findloc pure module function findloc_integer_dim1 ( array , value , dim , back ) result ( location ) !! Fortran 2003 emulation of Fortran 2008 intrinsic function findloc implicit none integer , intent ( in ) :: array (:), value , dim logical , intent ( in ), optional :: back integer location end function pure module function findloc_logical_dim1 ( array , value , dim , back ) result ( location ) implicit none logical , intent ( in ) :: array (:), value , back integer , intent ( in ) :: dim integer location end function pure module function findloc_character_dim1 ( array , value , dim , back ) result ( location ) implicit none character ( len =* ), intent ( in ) :: array (:), value integer , intent ( in ) :: dim logical , intent ( in ) :: back integer location end function end interface #endif /* EMULATE_INTRINSICS || defined EMULATE_FINDLOC */ end module intrinsics_m","tags":"","loc":"sourcefile/intrinsics_m.f90.html"},{"title":"intrinsics_s.F90 – ","text":"This file depends on sourcefile~~intrinsics_s.f90~~EfferentGraph sourcefile~intrinsics_s.f90 intrinsics_s.F90 sourcefile~intrinsics_m.f90 intrinsics_m.F90 sourcefile~intrinsics_s.f90->sourcefile~intrinsics_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules intrinsics_s Source Code intrinsics_s.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! submodule ( intrinsics_m ) intrinsics_s use assert_m , only : assert implicit none contains module procedure ensure_non_empty_instrinsic_m end procedure #if defined EMULATE_INTRINSICS || defined EMULATE_FINDLOC module procedure findloc_integer_dim1 if ( . not . present ( back )) then location = minloc ( array , dim , array == value ) else if ( back . eqv . . false .) then location = minloc ( array , dim , array == value ) else ! back is present and .true. so work around GCC 8 lack of support for the \"back\" argument block integer , parameter :: loop_increment =- 1 , base_index = 1 integer index_ call assert ( dim == 1 , \"findloc_integer_dim1: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) do index_ = ubound ( array , dim ), lower_bound , loop_increment if ( array ( index_ ) == value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end block end if end procedure module procedure findloc_logical_dim1 integer , parameter :: loop_increment =- 1 , base_index = 1 integer index_ call assert ( back . and . dim == 1 , \"findloc_logical_dim1_backtrue: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) do index_ = ubound ( array , dim ), lower_bound , loop_increment if ( array ( index_ ) . eqv . value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end procedure module procedure findloc_character_dim1 integer , parameter :: base_index = 1 integer index_ , loop_increment , start , finish call assert ( dim == 1 , \"findloc_character_dim1: unsupported use case\" ) associate ( lower_bound => lbound ( array , dim ) ) select case ( back ) case (. true .) start = ubound ( array , dim ) finish = lower_bound loop_increment =- 1 case (. false .) start = lower_bound finish = ubound ( array , dim ) loop_increment = 1 end select do index_ = start , finish , loop_increment if ( array ( index_ ) == value ) then location = index_ - lower_bound + base_index return end if end do end associate location = 0 end procedure #endif /* EMULATE_INTRINSICS || defined EMULATE_FINDLOC */ end submodule intrinsics_s","tags":"","loc":"sourcefile/intrinsics_s.f90.html"},{"title":"collectives_m.F90 – ","text":"Files dependent on this one sourcefile~~collectives_m.f90~~AfferentGraph sourcefile~collectives_m.f90 collectives_m.F90 sourcefile~collectives_s.f90 collectives_s.F90 sourcefile~collectives_s.f90->sourcefile~collectives_m.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules collectives_m Source Code collectives_m.F90 Source Code ! !     (c) 2019-2020 Guide Star Engineering, LLC !     This Software was developed for the US Nuclear Regulatory Commission (US NRC) under contract !     \"Multi-Dimensional Physics Implementation into Fuel Analysis under Steady-state and Transients (FAST)\", !     contract # NRC-HQ-60-17-C-0007 ! module collectives_m !! summary: Fortran 2008 coarray emulations of Fortran 2018 collective subroutines !! author: Damian Rouson use iso_fortran_env , only : real32 , real64 implicit none private #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_SUM public :: co_sum #endif #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_BROADCAST public :: co_broadcast #endif #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_REDUCE public :: co_reduce #endif interface module subroutine ensure_non_empty_collectives_m end subroutine end interface #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_SUM interface co_sum module subroutine co_sum_integer ( a , result_image , stat , errmsg ) !! parallel computation of the sum of the first argument implicit none integer , intent ( inout ) :: a integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_sum_real32_1D_array ( a , result_image , stat , errmsg ) implicit none real ( real32 ), intent ( inout ) :: a (:) integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_sum_real32_2D_array ( a , result_image , stat , errmsg ) implicit none real ( real32 ), intent ( inout ) :: a (:,:) integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_sum_real64_1D_array ( a , result_image , stat , errmsg ) implicit none real ( real64 ), intent ( inout ) :: a (:) integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_sum_real64_2D_array ( a , result_image , stat , errmsg ) implicit none real ( real64 ), intent ( inout ) :: a (:,:) integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine end interface #endif /* defined EMULATE_COLLECTIVES || defined EMULATE_CO_SUM */ #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_BROADCAST interface co_broadcast module subroutine co_broadcast_logical ( a , source_image , stat , errmsg ) !! parallel one-to-all communication of the value of first argument implicit none logical , intent ( inout ) :: a integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_integer ( a , source_image , stat , errmsg ) implicit none integer , intent ( inout ) :: a integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_real32_1D_array ( a , source_image , stat , errmsg ) implicit none real ( real32 ), intent ( inout ) :: a (:) integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_real32_2D_array ( a , source_image , stat , errmsg ) implicit none real ( real32 ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_real64_1D_array ( a , source_image , stat , errmsg ) implicit none real ( real64 ), intent ( inout ) :: a (:) integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine module subroutine co_broadcast_real64_2D_array ( a , source_image , stat , errmsg ) implicit none real ( real64 ), intent ( inout ) :: a (:,:) integer , intent ( in ) :: source_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine end interface #endif /* defined EMULATE_COLLECTIVES || defined EMULATE_CO_BROADCAST */ #if defined EMULATE_COLLECTIVES || defined EMULATE_CO_REDUCE interface co_reduce module subroutine co_reduce_logical ( a , operation , result_image , stat , errmsg ) !! parallel reduction of values across images of the first argument implicit none abstract interface pure function operation_i ( x , y ) logical , intent ( in ) :: x , y logical :: operation_i end function end interface logical , intent ( inout ) :: a procedure ( operation_i ) :: operation integer , intent ( in ), optional :: result_image integer , intent ( out ), optional :: stat character ( len =* ), intent ( inout ), optional :: errmsg end subroutine end interface #endif /* defined EMULATE_COLLECTIVES || defined EMULATE_CO_REDUCE */ end module collectives_m","tags":"","loc":"sourcefile/collectives_m.f90.html"},{"title":"ensure_non_empty_instrinsic_m – ","text":"interface Calls interface~~ensure_non_empty_instrinsic_m~~CallsGraph interface~ensure_non_empty_instrinsic_m ensure_non_empty_instrinsic_m proc~ensure_non_empty_instrinsic_m ensure_non_empty_instrinsic_m interface~ensure_non_empty_instrinsic_m->proc~ensure_non_empty_instrinsic_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine ensure_non_empty_instrinsic_m() Implementation → Arguments None","tags":"","loc":"interface/ensure_non_empty_instrinsic_m.html"},{"title":"ensure_non_empty_collectives_m – ","text":"interface Calls interface~~ensure_non_empty_collectives_m~~CallsGraph interface~ensure_non_empty_collectives_m ensure_non_empty_collectives_m proc~ensure_non_empty_collectives_m ensure_non_empty_collectives_m interface~ensure_non_empty_collectives_m->proc~ensure_non_empty_collectives_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. private module module subroutine ensure_non_empty_collectives_m() Implementation → Arguments None","tags":"","loc":"interface/ensure_non_empty_collectives_m.html"},{"title":"ensure_non_empty_collectives_m – ","text":"module procedure ensure_non_empty_collectives_m module module subroutine ensure_non_empty_collectives_m() Interface → Arguments None Called by proc~~ensure_non_empty_collectives_m~~CalledByGraph proc~ensure_non_empty_collectives_m ensure_non_empty_collectives_m interface~ensure_non_empty_collectives_m ensure_non_empty_collectives_m interface~ensure_non_empty_collectives_m->proc~ensure_non_empty_collectives_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ensure_non_empty_collectives_m.html"},{"title":"ensure_non_empty_instrinsic_m – ","text":"module procedure ensure_non_empty_instrinsic_m module module subroutine ensure_non_empty_instrinsic_m() Interface → Arguments None Called by proc~~ensure_non_empty_instrinsic_m~~CalledByGraph proc~ensure_non_empty_instrinsic_m ensure_non_empty_instrinsic_m interface~ensure_non_empty_instrinsic_m ensure_non_empty_instrinsic_m interface~ensure_non_empty_instrinsic_m->proc~ensure_non_empty_instrinsic_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/ensure_non_empty_instrinsic_m.html"},{"title":"intrinsics_m – ","text":"Used by Descendants: intrinsics_s module~~intrinsics_m~~UsedByGraph module~intrinsics_m intrinsics_m module~intrinsics_s intrinsics_s module~intrinsics_s->module~intrinsics_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ensure_non_empty_instrinsic_m Interfaces interface private module module subroutine ensure_non_empty_instrinsic_m() Implementation → Arguments None","tags":"","loc":"module/intrinsics_m.html"},{"title":"collectives_m – ","text":"Uses iso_fortran_env module~~collectives_m~~UsesGraph module~collectives_m collectives_m iso_fortran_env iso_fortran_env module~collectives_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: collectives_s module~~collectives_m~~UsedByGraph module~collectives_m collectives_m module~collectives_s collectives_s module~collectives_s->module~collectives_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces ensure_non_empty_collectives_m Interfaces interface private module module subroutine ensure_non_empty_collectives_m() Implementation → Arguments None","tags":"","loc":"module/collectives_m.html"},{"title":"collectives_s – ","text":"Uses assert_m Ancestors: collectives_m module~~collectives_s~~UsesGraph module~collectives_s collectives_s module~collectives_m collectives_m module~collectives_s->module~collectives_m assert_m assert_m module~collectives_s->assert_m iso_fortran_env iso_fortran_env module~collectives_m->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ensure_non_empty_collectives_m Module Procedures module procedure ensure_non_empty_collectives_m module module subroutine ensure_non_empty_collectives_m() Interface → Arguments None","tags":"","loc":"module/collectives_s.html"},{"title":"intrinsics_s – ","text":"Uses assert_m Ancestors: intrinsics_m module~~intrinsics_s~~UsesGraph module~intrinsics_s intrinsics_s module~intrinsics_m intrinsics_m module~intrinsics_s->module~intrinsics_m assert_m assert_m module~intrinsics_s->assert_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures ensure_non_empty_instrinsic_m Module Procedures module procedure ensure_non_empty_instrinsic_m module module subroutine ensure_non_empty_instrinsic_m() Interface → Arguments None","tags":"","loc":"module/intrinsics_s.html"}]}